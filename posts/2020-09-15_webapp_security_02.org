---
title: Webアプリケーションセキュリティ - クロスサイト・リクエストフォージェリ（CSRF）
published: 2020-09-15 15:50:32
tags: security
---
#+OPTIONS: ^:{}
#+OPTIONS: \n:t

会社の金で勉強できるぞ！ということで、普段なかなか触る機会のないセキュリティについて勉強する。
特に、よくある脆弱性とその対策方法を、サンプルコード等を用いた攻撃を通して理解したい。

この記事では、クロスサイト・リクエストフォージェリについて、概要と基本的な対策について記載する。

なお、今回学習に使用する資料はこちら。
- [[https://www.amazon.co.jp/%25E4%25BD%2593%25E7%25B3%25BB%25E7%259A%2584%25E3%2581%25AB%25E5%25AD%25A6%25E3%2581%25B6-%25E5%25AE%2589%25E5%2585%25A8%25E3%2581%25AAWeb%25E3%2582%25A2%25E3%2583%2597%25E3%2583%25AA%25E3%2582%25B1%25E3%2583%25BC%25E3%2582%25B7%25E3%2583%25A7%25E3%2583%25B3%25E3%2581%25AE%25E4%25BD%259C%25E3%2582%258A%25E6%2596%25B9-%25E7%25AC%25AC2%25E7%2589%2588-%25E8%2584%2586%25E5%25BC%25B1%25E6%2580%25A7%25E3%2581%258C%25E7%2594%259F%25E3%2581%25BE%25E3%2582%258C%25E3%2582%258B%25E5%258E%259F%25E7%2590%2586%25E3%2581%25A8%25E5%25AF%25BE%25E7%25AD%2596%25E3%2581%25AE%25E5%25AE%259F%25E8%25B7%25B5-%25E5%25BE%25B3%25E4%25B8%25B8/dp/4797393165/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=][体系的に学ぶ 安全なWebアプリケーションの作り方 第2版 脆弱性が生まれる原理と対策の実践]]
- [[https://www.ipa.go.jp/files/000017316.pdf][安全なウェブサイトの作り方]] （IPA）

@@html:<!--more-->@@

* CSRFとは？なんじゃらほい
  IPA「[[https://www.ipa.go.jp/files/000017316.pdf][安全なウェブサイトの作り方]] - 1.6 CSRF（クロスサイト・リクエスト・フォージェリ）」は、以下の記載がある。
  #+begin_quote
  ログインした利用者からのリクエストについて、その利用者が意図したリクエストであるかどうかを識別する仕組みを持たないウェブサイトは、外部サイトを経由した悪意のあるリクエストを受け入れてしまう場合があります。
  #+end_quote
  
  書籍の方には、こう書いてある（一部編集）。
  #+begin_quote
  「ログインした利用者のアカウントにより実行される重要な処理（重要な処理）」の受付に際して、利用者の意図したリクエストであることを確認する処理が抜けている場合は、罠のサイトなどを閲覧しただけで、利用者のブラウザから勝手に「重要な処理」を実行させられる場合があります。
  #+end_quote

  いずれの記載も、 **ログインした利用者** 、つまり認証済みの利用者によるリクエストが、利用者が意図したリクエストであるか **確認していない** 場合に発生すると述べている。

  そして、「重要な処理」の実行が利用者の意図通りかを確認していないことにより、攻撃者が利用者本人になりすまし、
  悪意のあるリクエストを脆弱性のあるウェブアプリケーションに受け入れさせることができる。

  ここで、「重要な処理」として想定されるものは以下のようなものがある（書籍より引用）。
  - 利用者のアカウントによる物品の購入
  - 利用者の退会処理
  - 利用者のアカウントによるSNSや問い合わせフォームへの書き込み
  - 利用者のパスワードやメールアドレスの変更


  見てわかるとおり、全て利用者にとっての何らかの変更処理である。

  これは当然の話で、（後に述べるように）リクエストは利用者として発行されるので、レスポンスも当然利用者に対して返却される。
  そのため、CSRF攻撃により参照処理が、利用者が意図せず実施されたとしても、参照する情報が攻撃者に行くことはない。

  一方で、変更処理はサーバ側に対しての変更であるため、レスポンスの有無にかかわらず、利用者としてリクエストを発行できさえすればよい。
  
  CSRF攻撃にて、どのように悪意のあるリクエストを受け入れさせるか、大まかな流れは以下のとおりである。

  1. 攻撃者が、罠サイトを設置する。罠サイトには、脆弱性のあるウェブアプリケーションの「重要な処理」へのPOSTリクエストを実行するJavascriptなどが埋め込まれている。
     POSTリクエストの ~form-data~ には、攻撃者が脆弱性のあるウェブアプリケーションに受け入れさせたいデータを記載する。
  2. 利用者が、脆弱性のあるウェブアプリケーションにログインした状態で、罠サイトへアクセスする。
     利用者はログイン済みであり、セッションid等はクッキーから読み取られ、リクエストヘッダに設定される。
     結果として、罠サイトに埋め込まれたJavascriptが、利用者として、利用者が意図せず実行される。


  罠サイトへの誘い出し方は、XSSのときと同じである。

** XSSとCSRFの違い
   XSSとCSRFは異なる種類の脆弱性を悪用した攻撃手法だが、以下の点で混同しやすいのではないか？と思われる。
   （実際私も、最初はあまり違いがよくわからなかった）

   - 「クロスサイト」から始まる
   - 「脆弱性のあるウェブサイト」が登場する
   - 「罠となるサイト」が登場し、利用者がそこにアクセスすることで攻撃が開始される


   そこで、「実行させたいこと」と「脆弱性の存在する箇所」の2点で、XSSとCSRFを比較すると、以下のようになる。

   | 攻撃手法 | 実行させたいこと                                             | 脆弱性の存在する箇所                                               |
   |----------+--------------------------------------------------------------+--------------------------------------------------------------------|
   | XSS      | 閲覧者のブラウザ上で、任意の処理を実行                       | エスケープされることなく、入力値を出力の一部として使用している箇所 |
   | CSRF     | 利用者になりすまし、ウェブアプリケーションへの変更処理を実行 | 本人の意図通りかを確認せず、処理の実行を行っている箇所             |
   

   上記を見てみると、Javascriptの任意実行をさせる分、XSSのほうが質が悪そうに見える。
   しかし、書籍によると、

   - CSRFは設計段階から対策を盛り込む必要がある（後述）
   - 開発者への認知度がXSSより低く、対策が進んでいない


   とのことで、CSRFも要対策である。

* CSRFへの対策
  「リクエストが利用者の意図通りか」を確認することが、対策として必要である。
  意図通りであることの確認は、書籍により以下3つが挙げられている（詳細な解説は書籍参照）。

  1. 秘密情報（トークン）の埋め込み
  2. パスワード再入力
  3. Refererのチェック


  いずれの方式を選択するにしても、「どの処理が重要な処理に当たるか」を事前に（設計段階で）検討する必要がある。
  その上で、「重要な処理」においてのみ、CSRF対策を施すことが必要となってくる
  （上で述べたとおり、参照処理などはCSRF対策をしても意味がないため、無駄な工数増加となる）。


** 1について
   「重要な処理」の実行画面にて、セッションIDとは別に、セッション変数に格納された秘密情報（乱数で生成されたトークンなど）を ~<input>~ タグへ埋め込む
   （秘密情報が格納されていなければ生成する）。

   実行画面で「重要な処理」が実行されると、秘密情報も一緒にPOSTされる。
   ウェブアプリケーション側で、POSTされた秘密情報とセッション変数内の秘密情報を比較し、一致していたときのみ実行を継続する
   （なお、POSTされた秘密情報が空でないことも、合わせて確認する。セッション変数内の秘密情報が空の場合に、実行が継続されるのを防ぐため）。

   この方法において、秘密情報はサーバ側で保持しており、確認できるタイミングは「重要な処理」の実行画面に遷移したときのみである
   （クッキーにはセッションIDしか格納されていないため、ここから秘密情報を取り出すのは不可能である）。

   そのため、罠サイトから直接POSTリクエストしても、（秘密情報を知ることができない以上）「重要な処理」の実行は継続されない。

   秘密情報の生成や検証については、ウェブアプリケーションフレームワークなどで提供されていることも多い。
   例えば、[[https://nablarch.github.io/docs/LATEST/doc/application_framework/application_framework/handlers/web/csrf_token_verification_handler.html][∇Nablarch 5u17]]においては、「CSRFトークン検証ハンドラ」として、秘密情報の生成・検証を実施している
   （リクエストパラメータ経由だけでなく、リクエストヘッダに秘密情報を埋め込むこともできる）。

   なお、「重要な処理」の実行画面に秘密情報を埋め込むのは、アプリケーション開発者側で実施する必要がある
   （秘密情報の埋め込みがされていない場合は、検証時に単にCSRF攻撃だと判定されるだけであり、容易に検出可能である）。


** 2について
   これまた「重要な処理」の実行画面で、利用者にパスワードの再入力を求める（パスワード変更画面で、現在のパスワードを入力させるのが好例）。
   こちらの方法でも、攻撃者が知りえない情報を合わせて送信することで、実行が本人の意図通りであることを確認することができる。
   
   他にも、共用PCなどで複数の利用者が存在する場合など、本人確認も合わせて必要な場面では、こちらを採用することも検討できる。

   なお、こちらの方法を採用する場合は、パスワード入力をさせるための画面にする必要があるため、開発コストは大きくなる。


** 3について
   利用者が正規の方法でリクエストを送る場合と、罠サイトを訪れて自動的にリクエストが送信される場合、両者のリクエストヘッダ内Refererフィールドは異なる。
   そのため、Refererが実行画面のURLになっているかを確認することで、そのリクエストが正規のものか否かを確認することができる。

   ただし、利用者によってはRefererフィールドの送信を無効にしている場合もある。
   その場合は、利用者が当該サイトを使用できなくなってしまうため、Refererフィールドがリクエストヘッダに含まれることが保証される場合は採用できる。


** 確認ページを設けること
   ウェブアプリケーションの中には、「重要な処理」の実行画面にて、実行内容の確認を利用者に求めるものがある（いわゆる確認画面）。
   利用者の利便性の確保のためには良いものだが、これだけではCSRF対策にはならない（Javascriptの記載を工夫して、POSTリクエストを時間差で多段に実行できるようにするだけで回避できる）。
   
    かならず、「重要な処理」の実行画面で、上の対策を実施することが必要である。


** ログインしていない状態でのCSRF攻撃に対する対策
   ログインしていない状態であっても、ウェブアプリケーションへのPOST処理などが発生する場合は、CSRF攻撃が成立しうる
   （例えば、[[https://ja.wikipedia.org/wiki/%25E3%2583%2591%25E3%2582%25BD%25E3%2582%25B3%25E3%2583%25B3%25E9%2581%25A0%25E9%259A%2594%25E6%2593%258D%25E4%25BD%259C%25E4%25BA%258B%25E4%25BB%25B6][パソコン遠隔操作事件]]は記憶に新しい）。

   ログインしていないので、対策の1,2については実施できないが、3のRefererチェックについては、引き続き有効な手段となりうる。


** 保険的対策
   上記の対策以外に、保険的対策として以下のことも実施できる。

   - 「重要な処理」実行後、利用者宛に通知を送る ::
        処理の実行自体を止めることはできないが、これにより「重要な処理」不正に実行された場合に、利用者が検知できる可能性が高まる。
   
* まとめ
  CSRFは、「重要な処理」の実行に際し、本人の実行意図を確認しないことで発生しうる攻撃である。
  そのため、何らかの方法で、実行が本人の意図通りであることを確認する必要がある。

  上でも書いたが、初学だとXSSとCSRFの違いがよくわからない・・・のだが、攻撃により実現したいことは全く異なるので、この観点で見ていくと、結構整理しやすいかもしれない。
  また、XSSとは違って、ある程度インフラ・共通部品的なものでカバーできそうなので、そこはXSSより対策がしやすそうに思える。
